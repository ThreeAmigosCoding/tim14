{% extends "base.html" %}
{% block main_canvas %}

<style>
    circle{
    fill: #00FFF5;
    }
    text{
        fill: #222831;
    }
    line{
        stroke: white;
    }
</style>

<style>

    .node-data {
        width: 200px;
        height: 300px;
        overflow-y: auto;
        display: block;
        position: absolute;
        bottom: 0;
        right: 0;
        background-color: #393E46;
        padding: 20px;
        border: none;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        margin: 0;
        z-index: 9999;
    }

    .node-data p {
        word-wrap: break-word;
    }

</style>

<div style="position: relative; border: none; margin: 0; padding: 0;">
    <div id="node-data" class="node-data">
        <h2 style="margin: 0" id="node-data-title">Node Data</h2>
        <p id="nodeData"></p>
    </div>
</div>

<script src='https://d3js.org/d3.v3.min.js'></script>
<script>
    let nodes={
        {% for node in nodes %}
            {% if node.enabled == True %}
                "{{node.node_id}}":{id:"{{node.node_id}}", data: [
                    {% for attribute in node.data.all %}
                        {#"{{ attribute }}",#}
                        {name: "{{attribute.name}}", value: "{{attribute.value}}"},
                    {% endfor %}
                ], node_name:"{{ node.name }}"},
            {% endif %}
        {% endfor %}
        };
    let edges=[
        {% for edge in edges %}
            {% if edge.enabled == True %}
                {source:"{{edge.start_node.node_id}}",target:"{{edge.end_node.node_id}}"},
            {% endif %}
        {% endfor %}
    ]
    edges.forEach(function(link) {
        link.source = nodes[link.source];
        link.target = nodes[link.target];
    });

    const width = document.getElementById("main-canvas-svg").clientWidth;
    const height = document.getElementById("main-canvas-svg").clientHeight;

    function formatNodeData(data) {
        let formattedData = "";
        for (let atr of data)
            formattedData += atr.name + ": " + atr.value + "\n\n";
        return formattedData;
    }

    let force = d3.layout.force()
        .size([width, height])
        .nodes(d3.values(nodes))
        .links(edges)
        .on("tick", tick)
        .linkDistance(300)
        .linkStrength(5)
        .charge(-1000).start();

    let svg = d3.select('svg#main-canvas-svg').append("g");
    let edgeComp = svg.selectAll('.edge')
        .data(edges)
        .enter().append('line')
        .attr('class', 'edge');
    let nodeComp = svg.selectAll('.node')
        .data(force.nodes())
        .enter().append('g')
        .attr('class', 'node')
        .attr('id', function(d){return d.id;})
        .attr('data', function(d){return d.data;})
        .on("click", function(d) {
            document.getElementById("nodeData").innerText = formatNodeData(d.data);
            document.getElementById("node-data-title").innerText = d.id + " : " + d.node_name;
        });

    d3.selectAll('.node').each(function(d){complexDisplay(d);});

    function complexDisplay(d) {
        let length = 150;
        let dataLength = d.data.length;

        let textSize = 16;
        let lineHeight = 1.2 * textSize; // Line height for wrapped text

        let height = (dataLength === 0) ? textSize : dataLength * lineHeight;
        height += textSize * 4;

        let complexDisplayGroup = d3.select("g[id='" + d.id + "']");

        let container = complexDisplayGroup.append('rect')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', length)
            .attr('height', height)
            .attr('fill', '#00FFF5')
            .attr('rx', 5)
            .attr('ry', 5);

        complexDisplayGroup.append('text')
            .attr('x', length / 2)
            .attr('y', textSize)
            .attr('text-anchor', 'middle')
            .attr('font-size', textSize)
            .attr('font-family', 'sans-serif')
            .attr('fill', 'black')
            .text(d.id + " : " + d.node_name);

        complexDisplayGroup.append('line')
            .attr('x1', 0)
            .attr('y1', lineHeight)
            .attr('x2', length)
            .attr('y2', lineHeight)
            .attr('stroke', 'black')
            .attr('stroke-width', 2);

        for (let i = 0; i < dataLength; i++) {
            let text = complexDisplayGroup.append('text')
              .attr('x', 5)
              .attr('y', (i + 1) * lineHeight) // Adjust the y-coordinate for wrapped lines
              .attr('font-size', textSize)
              .attr('font-family', 'sans-serif')
              .attr('fill', 'black');

            let words = d.data[i].name + ': ' + d.data[i].value;
            let wordsArray = words.split(' ');

            let lineNumber = 0;
            let tspan = text.append('tspan')
                .attr('x', 5)
                .attr('dy', lineHeight)
                .text(wordsArray[0]);

            for (let j = 1; j < wordsArray.length; j++) {
                let word = wordsArray[j];
                let currentLine = tspan.text();
                tspan.text(currentLine + ' ' + word);

                if (tspan.node().getComputedTextLength() > length - 10) {
                    tspan.text(currentLine); // Remove the last word from the current line
                    lineNumber++;
                    height += lineHeight;

                    text = complexDisplayGroup.append('text') // Create a new <text> element for the new line
                      .attr('x', 5)
                      .attr('y', (i + 1 + lineNumber) * lineHeight)
                      .attr('font-size', textSize)
                      .attr('font-family', 'sans-serif')
                      .attr('fill', 'black');

                    tspan = text.append('tspan')
                      .attr('x', 5)
                      .attr('dy', lineHeight)
                      .text(word); // Start a new <tspan> for the current word
                } else {
                    tspan.text(currentLine + ' ' + word);
                }
            }

        }
        container.attr('height', height);
    }

    function updateNodes(){
        nodeComp.attr("transform", function(d) {return "translate(" + d.x + "," + d.y + ")";})
            .call(force.drag);
    }
    function updateEdges(){
        edgeComp.attr('x1', function(d){
                return d.source.x;
            })
            .attr('y1', function(d){
                return d.source.y;
            })
            .attr('x2', function(d){
                return d.target.x;
            })
            .attr('y2', function(d){
                return d.target.y;
            });
    }
    function tick() {
        updateNodes();
        updateEdges();
        d3.selectAll("#main-canvas-svg g g").on("mousedown", function() {
        d3.event.stopImmediatePropagation(); });

        if (typeof updateBirdView === 'function') {
            updateBirdView();
        }
    }

</script>
{% endblock %}